---
title:  "채팅 프로그램을 만들자 - 접속한 유저를 확인하는 방법"
excerpt: ""

categories: [Side Project, ChattingProgram]
tags: [SideProject, C&#47;C&#43;&#43;]

toc: true
toc_sticky: true
 
date: 2025-03-28
last_modified_at: 2025-03-28
---

> 포스트 **'채팅 프로그램을 만들자' 시리즈**에서는 프로젝트가  
> 어떤 의도로 설계 되었는지부터 서버 프로그램에서 IOCP를 1개가 아닌 여러 개를 사용하도록 변경한 이유까지  
> 프로젝트를 진행하면서 있었던 일들을 다룰 예정입니다.  

> 이전 포스트인 ["채팅 프로그램을 만들자 - 프로젝트 기본 설정하기"](https://mgcllee.github.io/posts/ChattingProgram01/)와 내용이 이어집니다.  

<br/>

## 접속 유저 관리가 필요한 이유
---

여러 유저가 채팅만 송수신하는 것은 서버의 스트레스 테스트로서 부족하다고 판단하여  
서버와 연결을 끊고 재접속을 시도할 수 있도록 구현하고 있었습니다. 그러나 여기서 문제가 생겼습니다.  

클라이언트에서는 closesocket 메서드를 호출하여 소켓 연결을 종료했지만 서버에서는 소켓이 해제되지 않아  
불필요한 메모리 사용량이 늘어난다는 문제점이였습니다.  
메모리의 크기가 아무리 크다고 하더라도 해제되지 않은 소켓이 쌓이면 결국 메모리를 전부 사용하게 되고  
그로 인해서 프로세스가 정상적으로 실행되지 못하여 치명적인 결과를 낳게 될 것입니다.  

따라서 불필요한 자원을 해제해 이 문제를 해결하고자 하였습니다.  

<br/>

## TCP 기반 첫 번째 시도
---

MFC로 만들어진 LogViewer 프로그램은 현재 접속 중인 유저 수와 서버가 수신한 채팅 내용을 출력하는 역할을 하였습니다.  
접속 유저의 수는 일정한 시간 마다 특정 패킷을 전송하여 클라이언트가 정상 수신하는지 확인하는 방법으로 접속 유저의 수를 확인했습니다.  

그러나 이 프로젝트에서 사용 중인 클라이언트는 한 프로그램에서 인스턴스로 존재하는 더미 클라이언트로  
동기 소켓으로 만들어진 클라이언트들이 동시에 위에서 언급한 특정 패킷을 수신할 수 없었습니다.  

따라서 접속한 유저 수를 정확하게 파악할 수 없다는 문제점이 있었습니다.  

<br/>

## UDP Multicast 고려하기
---

두 번째 시도에서는 Multicast를 사용한 유저 수 확인이였습니다.  
Multicast는 비연결성 프로토콜인 UDP를 사용하기 때문에 TCP보다 비교적 빠르게 전송이 가능하다는 특징이 있어서  
고려 대상이 되었습니다. 그러나 Multicast 구현까지는 이어지지 않았습니다.  

UDP는 비연결성이 있어 TCP보다는 빠를 수 있지만 신뢰성이 떨어져  
**유저의 수를 정확하게 파악하고자 하는 원래의 목적**에 적절하지 않다고 판단했기 때문입니다.  

<br/>

## TCP 소켓 설정 기반 세 번째 시도
---

위와 같이 여러 방법을 고민하던 중 찾은 것이 KEEP ALIVE 라는 TCP 소켓 옵션이였습니다.  

<!-->Heart Beat 생각하기기<-->

<br/>

## 비교 정리

<!-->TCP 기반 직접 확인, UDP 멀티캐스트 확인, TCP 소켓 설정 확인 비교 표 제작<-->

<br/>

## 후기

소개 글에서 설명한 것처럼 서버에서는 효율적인 자원 관리를 위해서  
유효한 접속만 유지하고 유효하지 않은 접속은 끊을 수 있습니다.  

<br/>

### 참고

[TCP 소켓에서 KEEPALIVE 옵션 사용](https://blog.naver.com/corinet/220771742989)  
<br/>
